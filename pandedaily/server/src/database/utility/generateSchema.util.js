// scripts/generateSchema.script.js - FIXED PATHS

const fs = require('fs')
const path = require('path')

// --- Configuration ---
// FIXED: Corrected paths - models are in database/model, not just model
const modelsDir = path.join(__dirname, '..', 'model') // Now points to server/src/database/model
const outputDir = path.join(__dirname, '..', '..', 'schemas') // Now points to server/src/schemas

// Columns that are typically handled by the database and excluded from the main INSERT/UPDATE schema.
const EXCLUDED_COLUMNS = ['createddate', 'updateddate', 'deleteddate', 'createdby', 'updatedby']

// --- Utility Functions ---

/**
 * Converts a snake_case string (e.g., master_cost) to PascalCase (MasterCost).
 */
const toPascalCase = (snakeCase) => {
  return snakeCase
    .split('_')
    .map((word) => word.charAt(0).toUpperCase() + word.slice(1))
    .join('')
}

/**
 * Converts a snake_case string (e.g., category_name) to camelCase (categoryName).
 */
const toCamelCase = (snakeCase) => {
  return snakeCase.replace(/([-_][a-z])/gi, ($1) => {
    return $1.toUpperCase().replace('-', '').replace('_', '')
  })
}

/**
 * Maps a Sequelize type to a Joi chain string and the primary Joi error key.
 */
const joiTypeMapper = (sequelizeType) => {
  switch (sequelizeType.toUpperCase()) {
    case 'INTEGER':
    case 'BIGINT':
      return { chain: 'Joi.number().integer()', baseKey: 'number.base' }
    case 'FLOAT':
    case 'REAL':
    case 'DOUBLE':
      return { chain: 'Joi.number()', baseKey: 'number.base' }
    case 'BOOLEAN':
      return { chain: 'Joi.boolean()', baseKey: 'boolean.base' }
    case 'DATE':
    case 'DATEONLY':
      return { chain: 'Joi.string().isoDate()', baseKey: 'string.empty' }
    case 'TEXT':
    case 'STRING':
    default:
      return { chain: 'Joi.string().trim()', baseKey: 'string.empty' }
  }
}

/**
 * Creates the field constants string for inclusion in the schema file, appending 'Field' to the name.
 */
const createFieldConstantsContent = (tableName, fields) => {
  const capitalize = (s) => s.charAt(0).toUpperCase() + s.slice(1)

  // This is the PascalCase name used for the export and constant variable
  const baseName = `${toPascalCase(tableName)}Field`

  let content = `\n\n/** Field references for clean, type-safe access */\n`
  content += `const ${baseName} = {\n`

  fields.forEach((field) => {
    // Generates the PascalCase property access key (e.g., Fullname)
    const fieldKey = field
      .replace(/([-_][a-z])/gi, ($1) => {
        return $1.toUpperCase().replace('-', '').replace('_', '')
      })
      .replace(/^\w/, (c) => c.toUpperCase())

    content += `    ${fieldKey}: '${field}',\n`
  })

  // Add the convenient 'All' array
  content += `    All: [${fields.map((f) => `'${f}'`).join(', ')}],\n`
  content += `};\n`

  // Return the PascalCase name as the export name (e.g., MasterVendorField)
  return { content, exportName: baseName }
}

// --- Schema File Content Generator (INCLUDES FIELDS) ---

const createSchemaFileContent = (tableName, schemaName, allColumns, dataTypes) => {
  const finalColumns = allColumns.filter((col) => !EXCLUDED_COLUMNS.includes(col))

  // 1. Generate the Joi Schema Fields part
  const schemaFields = finalColumns
    .map((col) => {
      // FIX: Use camelCase for the schema property name
      const camelCaseCol = toCamelCase(col)

      const sequelizeType = dataTypes[col] || 'STRING'
      const { chain: joiBaseChain, baseKey: joiErrorKey } = joiTypeMapper(sequelizeType)

      const joiChain = `${joiBaseChain}.required()`

      return ` 	${camelCaseCol}: ${joiChain}.messages({
        'any.required': '${camelCaseCol} is required.',
        '${joiErrorKey}': '${camelCaseCol} must be a valid ${sequelizeType.toLowerCase()}.',
      })`
    })
    .join(',\n')

  // 2. Generate the Field Constants part
  const { content: fieldConstants, exportName: fieldsExportName } = createFieldConstantsContent(
    tableName,
    allColumns
  )

  // 3. Assemble the final file content
  return `
// THIS FILE IS AUTO-GENERATED by a script.
// Joi data types and error messages are automatically mapped for INSERT/UPDATE.

const Joi = require('joi');

const ${schemaName} = Joi.object({
${schemaFields}
});
${fieldConstants}

module.exports = {
  ${schemaName},
  ${fieldsExportName}, 
};
`
}

// --- Find Schema Generator (Updated for camelCase PK validation) ---

const createFindSchemaFileContent = (schemaName, pkColumn, dataTypes) => {
  // FIX: Use camelCase for the property name in the find schema
  const camelCaseCol = toCamelCase(pkColumn)

  const sequelizeType = dataTypes[pkColumn] || 'STRING'
  const { chain: joiBaseChain, baseKey: joiErrorKey } = joiTypeMapper(sequelizeType)

  const joiChain = `${joiBaseChain}.required()`

  const schemaField = ` 	${camelCaseCol}: ${joiChain}.messages({
        'any.required': '${camelCaseCol} is required.',
        '${joiErrorKey}': '${camelCaseCol} must be a valid ID type.',
    })`

  return `
// THIS FILE IS AUTO-GENERATED by a script. 
// This schema validates the Primary Key for use in GET, PUT, DELETE /:id routes.

const Joi = require('joi');

const ${schemaName} = Joi.object({
${schemaField}
});

module.exports = {
  ${schemaName},
};
`
}

// --- Main Execution ---

const main = () => {
  console.log('--- Starting Dynamic Schema Generation ---')
  console.log(`Looking for models in: ${modelsDir}`)
  console.log(`Output directory: ${outputDir}`)

  // Check if models directory exists
  if (!fs.existsSync(modelsDir)) {
    console.error(`‚ùå Models directory does not exist: ${modelsDir}`)
    console.log(`Please make sure your model files are in the correct location.`)
    return
  }

  if (!fs.existsSync(outputDir)) {
    fs.mkdirSync(outputDir, { recursive: true })
    console.log(`‚úÖ Created output directory: ${outputDir}`)
  }

  let modelFiles

  try {
    modelFiles = fs.readdirSync(modelsDir).filter((file) => file.endsWith('.js'))

    if (modelFiles.length === 0) {
      console.log(
        `‚ö†Ô∏è Warning: No .js files found in the models directory: ${modelsDir}. Skipping generation.`
      )
      return
    }

    console.log(`Found ${modelFiles.length} model files:`, modelFiles)

    for (const modelFile of modelFiles) {
      const fullModelPath = path.join(modelsDir, modelFile)
      console.log(`Processing: ${fullModelPath}`)

      delete require.cache[require.resolve(fullModelPath)]
      const modelExport = require(fullModelPath)
      const modelObject = modelExport[Object.keys(modelExport)[0]]

      if (!modelObject) {
        console.warn(`‚ö†Ô∏è Warning: Could not find main export object in ${modelFile}. Skipping.`)
        continue
      }

      for (const tableName in modelObject) {
        const table = modelObject[tableName]

        const allColumns = Object.keys(table.selectOptionColumns || {})
        const dataTypes = table.columnDataTypes || {}
        const primaryKey = table.primaryKeyColumn

        console.log(`  Table: ${tableName}, Columns: ${allColumns.length}, PK: ${primaryKey}`)

        // File Name (Kebab-case: master-vendor.schema.js)
        const baseFileName = tableName.replace(/_/g, '-')

        // PascalCase base name (MasterVendor)
        const basePascalName = toPascalCase(tableName)

        // 1. Generate COMBINED Schema (Joi + Field Constants)
        if (allColumns.length > 0) {
          // Schema variable name (e.g., MasterVendorSchema)
          const fullSchemaName = `${basePascalName}Schema`
          const fullOutputFileName = `${baseFileName}.schema.js`

          const fileContent = createSchemaFileContent(
            tableName,
            fullSchemaName,
            allColumns,
            dataTypes
          )
          const outputPath = path.join(outputDir, fullOutputFileName)

          fs.writeFileSync(outputPath, fileContent)
          console.log(`‚úÖ Generated Combined Schema & Fields: ${outputPath}`)
        }

        // 2. Generate FindByID Schema
        if (primaryKey) {
          // Find Schema variable name (e.g., MasterVendorFindSchema)
          const findSchemaName = `${basePascalName}FindSchema`
          const findOutputFileName = `${baseFileName}Find.schema.js`

          const fileContent = createFindSchemaFileContent(findSchemaName, primaryKey, dataTypes)
          const outputPath = path.join(outputDir, findOutputFileName)

          fs.writeFileSync(outputPath, fileContent)
          console.log(`üîé Generated Find Schema: ${outputPath}`)
        }
      }
    }
  } catch (error) {
    console.error(`‚ùå A fatal error occurred during schema generation:`)
    console.error(error.message)
    console.error(error.stack)
  }

  console.log('--- Schema Generation Complete ---')
}

main()
